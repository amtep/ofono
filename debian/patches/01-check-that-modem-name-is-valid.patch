Check that modem name is valid otherwise fallback to using type

From: Kalle Valo <kalle.valo@canonical.com>

Some Huawei modems (this one is from Huawei E620) have garbage as serial data:

E: ID_SERIAL=ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ_HUAWEI_Mobile_ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
E: ID_SERIAL_SHORT=ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ
E: ID_BUS=usb
E: ID_USB_INTERFACES=:ffffff:080650:
E: ID_VENDOR_FROM_DATABASE=Huawei Technologies Co., Ltd.
E: ID_MODEL_FROM_DATABASE=E620 USB Modem

Huawei plugin uses serial as the name for the modem. But because the
garbage is not a valid path name, modem creation fails.

Fix it by falling back to using type if the check for name fails.
---
 src/modem.c |   13 ++++++++++---
 1 files changed, 10 insertions(+), 3 deletions(-)

Index: ofono-0.36/src/modem.c
===================================================================
--- ofono-0.36.orig/src/modem.c	2010-11-22 11:07:30.000000000 -0500
+++ ofono-0.36/src/modem.c	2010-11-30 13:32:28.650200000 -0500
@@ -1335,6 +1335,7 @@
 struct ofono_modem *ofono_modem_create(const char *name, const char *type)
 {
 	struct ofono_modem *modem;
+	gboolean use_name;
 	char path[128];
 
 	DBG("name: %s, type: %s", name, type);
@@ -1345,10 +1346,16 @@
 	if (name && strlen(name) > 64)
 		return NULL;
 
-	if (name == NULL)
-		snprintf(path, sizeof(path), "/%s%d", type, next_modem_id);
-	else
+	if (name != NULL) {
+		snprintf(path, sizeof(path), "/%s", name);
+		use_name = __ofono_dbus_valid_object_path(path);
+	} else
+		use_name = FALSE;
+
+	if (use_name)
 		snprintf(path, sizeof(path), "/%s", name);
+	else
+		snprintf(path, sizeof(path), "/%s%d", type, next_modem_id);
 
 	if (__ofono_dbus_valid_object_path(path) == FALSE)
 		return NULL;
